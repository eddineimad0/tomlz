[1;38;5;0;48;5;224mFAIL[0m [1mvalid/array/array[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 2006, .month = 6, .day = 1 }, .time = date_time.Time{ .hour = 11, .minute = 0, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     input sent to parser-cmd:[0m
       ints = [1, 2, 3, ]
       floats = [1.1, 2.1, 3.1]
       strings = ["a", "b", "c"]
       dates = [
         1987-07-05T17:45:00Z,
         1979-05-27T07:32:00Z,
         2006-06-01T11:00:00Z,
       ]
       comments = [
                1,
                2, #this is ok
       ]

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 2006, .month = 6, .day = 1 }, .time = date_time.Time{ .hour = 11, .minute = 0, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/array/string-with-comma-2[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\n' in string literal

[1m     input sent to parser-cmd:[0m
       title = [
       """Client: XXXX,
       Job: XXXX""",
       "Code: XXXX"
       ]

[1m     output from parser-cmd (stdout):[0m
       {
       	"title": [
       {
       	"type": "string",
       	"value": "Client: XXXX,
       Job: XXXX"
       },
       {
       	"type": "string",
       	"value": "Code: XXXX"
       }
       ]
       }

[1m     want:[0m
       {
         "title": [
           {
             "type": "string",
             "value": "Client: XXXX,\nJob: XXXX"
           },
           {
             "type": "string",
             "value": "Code: XXXX"
           }
         ]
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/array/table-array-string-backslash[0m
[1;38;5;0;48;5;224m [0m    error: Allocation failure, Error=error.BadSyntax
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 1

[1m     input sent to parser-cmd:[0m
       foo = [ { bar="\"{{baz}}\""} ]

[1m     output from parser-cmd (stderr):[0m
       error: Allocation failure, Error=error.BadSyntax
       
       Exit 1

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/comment/everywhere[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 12, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = 420 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = null }

[1m     input sent to parser-cmd:[0m
       # Top comment.
         # Top comment.
       # Top comment.
       
       # [no-extraneous-groups-please]
       
       [group] # Comment
       answer = 42 # Comment
       # no-extraneous-keys-please = 999
       # Inbetween comment.
       more = [ # Comment
         # What about multiple # comments?
         # Can you handle it?
         #
                 # Evil.
       # Evil.
         42, 42, # Comments within arrays are fun.
         # What about multiple # comments?
         # Can you handle it?
         #
                 # Evil.
       # Evil.
       # ] Did I fool you?
       ] # Hopefully not.
       
       # Make sure the space between the datetime and "#" isn't lexed.
       dt = 1979-05-27T07:32:12-07:00  # c
       d = 1979-05-27 # Comment

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 12, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = 420 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = null }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/comment/tricky[0m
[1;38;5;0;48;5;224m [0m    error: Allocation failure, Error=error.BadValue
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 1

[1m     input sent to parser-cmd:[0m
       [section]#attached comment
       #[notsection]
       one = "11"#cmt
       two = "22#"
       three = '#'
       
       four = """# no comment
       # nor this
       #also not comment"""#is_comment
       
       five = 5.5#66
       six = 6#7
       8 = "eight"
       #nine = 99
       ten = 10e2#1
       eleven = 1.11e1#23
       
       ["hash#tag"]
       "#!" = "hash bang"
       arr3 = [ "#", '#', """###""" ]
       arr4 = [ 1,# 9, 9,
       2#,9
       ,#9
       3#]
       ,4]
       arr5 = [[[[#["#"],
       ["#"]]]]#]
       ]
       tbl1 = { "#" = '}#'}#}}

[1m     output from parser-cmd (stderr):[0m
       error: Allocation failure, Error=error.BadValue
       
       Exit 1

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/datetime/datetime[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     input sent to parser-cmd:[0m
       space = 1987-07-05 17:45:00Z
       lower = 1987-07-05t17:45:00z

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/datetime/local-date[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = null }

[1m     input sent to parser-cmd:[0m
       bestdayever = 1987-07-05

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = null }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/datetime/local-time[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = null, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = null } }
[1;38;5;0;48;5;224m [0m    Segmentation fault at address 0xffffffffffffffff
[1;38;5;0;48;5;224m [0m    ???:?:?: 0xa1fe9ff4af in ??? (???)
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\io\writer.zig:23:40: 0x7ff7fdc511c4 in writeAll (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                    index += try self.write(bytes[index..]);
[1;38;5;0;48;5;224m [0m                                           ^
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\fmt.zig:1026:13: 0x7ff7fdc7a7dd in formatBuf__anon_9778 (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                return writer.writeAll(buf);
[1;38;5;0;48;5;224m [0m                ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:169:34: 0x7ff7fdc4af8d in jsonStringifyValue__anon_5458 (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                            offset = try fmt.bufPrint(&offset_buffer, "Z", .{});
[1;38;5;0;48;5;224m [0m                                     ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:79:39: 0x7ff7fdc4305b in jsonStringifyTable (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                else => jsonStringifyValue(e.value_ptr.*, wr) catch return error.JsonStringifyError,
[1;38;5;0;48;5;224m [0m                                          ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:32:28: 0x7ff7fdc42be7 in main (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m        const json_out = toJson(allocator, parsed_table) catch |e| {
[1;38;5;0;48;5;224m [0m                               ^
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\start.zig:337:41: 0x7ff7fdc4100d in WinStartup (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m        std.debug.maybeEnableSegfaultHandler();
[1;38;5;0;48;5;224m [0m                                            ^
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x7fff13e07343 in ??? (KERNEL32.DLL)
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x7fff15b426b0 in ??? (ntdll.dll)
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 3

[1m     input sent to parser-cmd:[0m
       besttimeever = 17:45:00
       milliseconds = 10:32:00.555

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = null, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = null } }
       Segmentation fault at address 0xffffffffffffffff
       ???:?:?: 0xa1fe9ff4af in ??? (???)
       D:\Software\zig\lib\std\io\writer.zig:23:40: 0x7ff7fdc511c4 in writeAll (test-parser.exe.obj)
                       index += try self.write(bytes[index..]);
                                              ^
       D:\Software\zig\lib\std\fmt.zig:1026:13: 0x7ff7fdc7a7dd in formatBuf__anon_9778 (test-parser.exe.obj)
                   return writer.writeAll(buf);
                   ^
       E:\Code\Zig\toml\tests\test-parser.zig:169:34: 0x7ff7fdc4af8d in jsonStringifyValue__anon_5458 (test-parser.exe.obj)
                               offset = try fmt.bufPrint(&offset_buffer, "Z", .{});
                                        ^
       E:\Code\Zig\toml\tests\test-parser.zig:79:39: 0x7ff7fdc4305b in jsonStringifyTable (test-parser.exe.obj)
                   else => jsonStringifyValue(e.value_ptr.*, wr) catch return error.JsonStringifyError,
                                             ^
       E:\Code\Zig\toml\tests\test-parser.zig:32:28: 0x7ff7fdc42be7 in main (test-parser.exe.obj)
           const json_out = toJson(allocator, parsed_table) catch |e| {
                                  ^
       D:\Software\zig\lib\std\start.zig:337:41: 0x7ff7fdc4100d in WinStartup (test-parser.exe.obj)
           std.debug.maybeEnableSegfaultHandler();
                                               ^
       ???:?:?: 0x7fff13e07343 in ??? (KERNEL32.DLL)
       ???:?:?: 0x7fff15b426b0 in ??? (ntdll.dll)
       
       Exit 3

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/datetime/local[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1977, .month = 12, .day = 21 }, .time = date_time.Time{ .hour = 10, .minute = 32, .second = 0, .nano_sec = 555000000, .offset = null } }
[1;38;5;0;48;5;224m [0m    Segmentation fault at address 0xffffffffffffffff
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x1890fff83f in ??? (???)
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\io\writer.zig:23:40: 0x7ff7fdc511c4 in writeAll (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                    index += try self.write(bytes[index..]);
[1;38;5;0;48;5;224m [0m                                           ^
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\fmt.zig:1026:13: 0x7ff7fdc7a7dd in formatBuf__anon_9778 (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                return writer.writeAll(buf);
[1;38;5;0;48;5;224m [0m                ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:141:48: 0x7ff7fdc4a51b in jsonStringifyValue__anon_5458 (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                    value_string = try fmt.bufPrint(
[1;38;5;0;48;5;224m [0m                                                   ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:79:39: 0x7ff7fdc4305b in jsonStringifyTable (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                else => jsonStringifyValue(e.value_ptr.*, wr) catch return error.JsonStringifyError,
[1;38;5;0;48;5;224m [0m                                          ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:32:28: 0x7ff7fdc42be7 in main (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m        const json_out = toJson(allocator, parsed_table) catch |e| {
[1;38;5;0;48;5;224m [0m                               ^
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\start.zig:337:41: 0x7ff7fdc4100d in WinStartup (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m        std.debug.maybeEnableSegfaultHandler();
[1;38;5;0;48;5;224m [0m                                            ^
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x7fff13e07343 in ??? (KERNEL32.DLL)
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x7fff15b426b0 in ??? (ntdll.dll)
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 3

[1m     input sent to parser-cmd:[0m
       local = 1987-07-05T17:45:00
       milli = 1977-12-21T10:32:00.555
       space = 1987-07-05 17:45:00

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1977, .month = 12, .day = 21 }, .time = date_time.Time{ .hour = 10, .minute = 32, .second = 0, .nano_sec = 555000000, .offset = null } }
       Segmentation fault at address 0xffffffffffffffff
       ???:?:?: 0x1890fff83f in ??? (???)
       D:\Software\zig\lib\std\io\writer.zig:23:40: 0x7ff7fdc511c4 in writeAll (test-parser.exe.obj)
                       index += try self.write(bytes[index..]);
                                              ^
       D:\Software\zig\lib\std\fmt.zig:1026:13: 0x7ff7fdc7a7dd in formatBuf__anon_9778 (test-parser.exe.obj)
                   return writer.writeAll(buf);
                   ^
       E:\Code\Zig\toml\tests\test-parser.zig:141:48: 0x7ff7fdc4a51b in jsonStringifyValue__anon_5458 (test-parser.exe.obj)
                       value_string = try fmt.bufPrint(
                                                      ^
       E:\Code\Zig\toml\tests\test-parser.zig:79:39: 0x7ff7fdc4305b in jsonStringifyTable (test-parser.exe.obj)
                   else => jsonStringifyValue(e.value_ptr.*, wr) catch return error.JsonStringifyError,
                                             ^
       E:\Code\Zig\toml\tests\test-parser.zig:32:28: 0x7ff7fdc42be7 in main (test-parser.exe.obj)
           const json_out = toJson(allocator, parsed_table) catch |e| {
                                  ^
       D:\Software\zig\lib\std\start.zig:337:41: 0x7ff7fdc4100d in WinStartup (test-parser.exe.obj)
           std.debug.maybeEnableSegfaultHandler();
                                               ^
       ???:?:?: 0x7fff13e07343 in ??? (KERNEL32.DLL)
       ???:?:?: 0x7fff15b426b0 in ??? (ntdll.dll)
       
       Exit 3

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/datetime/milliseconds[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 600000000, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 123000000, .offset = date_time.TimeOffset{ .z = false, .minutes = -480 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 600000000, .offset = date_time.TimeOffset{ .z = false, .minutes = -480 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 123000000, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     input sent to parser-cmd:[0m
       utc1  = 1987-07-05T17:45:56.123Z
       utc2  = 1987-07-05T17:45:56.6Z
       wita1 = 1987-07-05T17:45:56.123+08:00
       wita2 = 1987-07-05T17:45:56.6+08:00

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 600000000, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 123000000, .offset = date_time.TimeOffset{ .z = false, .minutes = -480 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 600000000, .offset = date_time.TimeOffset{ .z = false, .minutes = -480 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 123000000, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/datetime/timezone[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = -720 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = 300 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = -780 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     input sent to parser-cmd:[0m
       utc  = 1987-07-05T17:45:56Z
       pdt  = 1987-07-05T17:45:56-05:00
       nzst = 1987-07-05T17:45:56+12:00
       nzdt = 1987-07-05T17:45:56+13:00  # DST

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = -720 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = 300 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = -780 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 56, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/example[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     input sent to parser-cmd:[0m
       best-day-ever = 1987-07-05T17:45:00Z
       
       [numtheory]
       boring = false
       perfection = [6, 28, 496]

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1987, .month = 7, .day = 5 }, .time = date_time.Time{ .hour = 17, .minute = 45, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/inline-table/empty[0m
[1;38;5;0;48;5;224m [0m    error: Allocation failure, Error=error.BadValue
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 1

[1m     input sent to parser-cmd:[0m
       empty1 = {}
       empty2 = { }
       empty_in_array = [ { not_empty = 1 }, {} ]
       empty_in_array2 = [{},{not_empty=1}]
       many_empty = [{},{},{}]
       nested_empty = {"empty"={}}

[1m     output from parser-cmd (stderr):[0m
       error: Allocation failure, Error=error.BadValue
       
       Exit 1

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/inline-table/key-dotted[0m
[1;38;5;0;48;5;224m [0m    error: Allocation failure, Error=error.BadValue
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 1

[1m     input sent to parser-cmd:[0m
       inline = {a.b = 42}
       
       many.dots.here.dot.dot.dot = {a.b.c = 1, a.b.d = 2}
       
       a = {   a.b  =  1   }
       b = {   "a"."b"  =  1   }
       c = {   a   .   b  =  1   }
       d = {   'a'   .   "b"  =  1   }
       e = {a.b=1}
       
       [tbl]
       a.b.c = {d.e=1}
       
       [tbl.x]
       a.b.c = {d.e=1}
       
       [[arr]]
       t = {a.b=1}
       T = {a.b=1}
       
       [[arr]]
       t = {a.b=2}
       T = {a.b=2}

[1m     output from parser-cmd (stderr):[0m
       error: Allocation failure, Error=error.BadValue
       
       Exit 1

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/inline-table/multiline[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\n' in string literal

[1m     input sent to parser-cmd:[0m
       tbl_multiline = { a = 1, b = """
       multiline
       """, c = """and yet
       another line""", d = 4 }

[1m     output from parser-cmd (stdout):[0m
       {
       	"tbl_multiline": {
       	"b": {
       	"type": "string",
       	"value": "multiline
       "
       },
       	"a": {
       	"type": "integer",
       	"value": "1"
       },
       	"c": {
       	"type": "string",
       	"value": "and yet
       another line"
       },
       	"d": {
       	"type": "integer",
       	"value": "4"
       }
       }
       
       }

[1m     want:[0m
       {
         "tbl_multiline": {
           "a": {
             "type": "integer",
             "value": "1"
           },
           "b": {
             "type": "string",
             "value": "multiline\n"
           },
           "c": {
             "type": "string",
             "value": "and yet\nanother line"
           },
           "d": {
             "type": "integer",
             "value": "4"
           }
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/key/dotted-empty[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\x01' in string literal

[1m     input sent to parser-cmd:[0m
       ''.x = "empty.x"
       x."" = "x.empty"
       [a]
       "".'' = "empty.empty"

[1m     output from parser-cmd (stdout):[0m
       {
       	"x": {
       	"": {
       	"type": "string",
       	"value": "x.empty"
       }
       }
       ,
       	"a": {
       	"": {
       	"": {
       	"type": "string",
       	"value": "empty.empty"
       }
       }
       
       }
       ,
       	"": {
       	"x": {
       	"type": "string",
       	"value": "empty.x"
       }
       }
       
       }

[1m     want:[0m
       {
         "": {
           "x": {
             "type": "string",
             "value": "empty.x"
           }
         },
         "x": {
           "": {
             "type": "string",
             "value": "x.empty"
           }
         },
         "a": {
           "": {
             "": {
               "type": "string",
               "value": "empty.empty"
             }
           }
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/key/dotted[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character ',' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       # Note: this file contains literal tab characters.
       
       name.first = "Arthur"
       "name".'last' = "Dent"
       
       many.dots.here.dot.dot.dot = 42
       
       # Space are ignored, and key parts can be quoted.
       count.a       = 1
       count . b     = 2
       "count"."c"   = 3
       "count" . "d" = 4
       'count'.'e'   = 5
       'count' . 'f' = 6
       "count".'g'   = 7
       "count" . 'h' = 8
       count.'i'     = 9
       count 	.	 'j'	   = 10
       "count".k     = 11
       "count" . l   = 12
       
       [tbl]
       a.b.c = 42.666
       
       [a.few.dots]
       polka.dot = "again?"
       polka.dance-with = "Dot"
       
       [[arr]]
       a.b.c=1
       a.b.d=2
       
       [[arr]]
       a.b.c=3
       a.b.d=4

[1m     output from parser-cmd (stdout):[0m
       {
       	"arr": ,
       	"many": {
       	"dots": {
       	"here": {
       	"dot": {
       	"dot": {
       	"dot": {
       	"type": "integer",
       	"value": "42"
       }
       }
       
       }
       
       }
       
       }
       
       }
       ,
       	"tbl": {
       	"a": {
       	"b": {
       	"c": {
       	"type": "float",
       	"value": "42.666"
       }
       }
       
       }
       
       }
       ,
       	"a": {
       	"few": {
       	"dots": {
       	"polka": {
       	"dot": {
       	"type": "string",
       	"value": "again?"
       },
       	"dance-with": {
       	"type": "string",
       	"value": "Dot"
       }
       }
       
       }
       
       }
       
       }
       ,
       	"name": {
       	"first": {
       	"type": "string",
       	"value": "Arthur"
       },
       	"last": {
       	"type": "string",
       	"value": "Dent"
       }
       }
       ,
       	"count": {
       	"k": {
       	"type": "integer",
       	"value": "11"
       },
       	"a": {
       	"type": "integer",
       	"value": "1"
       },
       	"g": {
       	"type": "integer",
       	"value": "7"
       },
       	"l": {
       	"type": "integer",
       	"value": "12"
       },
       	"d": {
       	"type": "integer",
       	"value": "4"
       },
       	"b": {
       	"type": "integer",
       	"value": "2"
       },
       	"c": {
       	"type": "integer",
       	"value": "3"
       },
       	"i": {
       	"type": "integer",
       	"value": "9"
       },
       	"e": {
       	"type": "integer",
       	"value": "5"
       },
       	"f": {
       	"type": "integer",
       	"value": "6"
       },
       	"h": {
       	"type": "integer",
       	"value": "8"
       },
       	"j": {
       	"type": "integer",
       	"value": "10"
       }
       }
       
       }

[1m     want:[0m
       {
         "a": {
           "few": {
             "dots": {
               "polka": {
                 "dance-with": {
                   "type": "string",
                   "value": "Dot"
                 },
                 "dot": {
                   "type": "string",
                   "value": "again?"
                 }
               }
             }
           }
         },
         "arr": [
           {
             "a": {
               "b": {
                 "c": {
                   "type": "integer",
                   "value": "1"
                 },
                 "d": {
                   "type": "integer",
                   "value": "2"
                 }
               }
             }
           },
           {
             "a": {
               "b": {
                 "c": {
                   "type": "integer",
                   "value": "3"
                 },
                 "d": {
                   "type": "integer",
                   "value": "4"
                 }
               }
             }
           }
         ],
         "count": {
           "a": {
             "type": "integer",
             "value": "1"
           },
           "b": {
             "type": "integer",
             "value": "2"
           },
           "c": {
             "type": "integer",
             "value": "3"
           },
           "d": {
             "type": "integer",
             "value": "4"
           },
           "e": {
             "type": "integer",
             "value": "5"
           },
           "f": {
             "type": "integer",
             "value": "6"
           },
           "g": {
             "type": "integer",
             "value": "7"
           },
           "h": {
             "type": "integer",
             "value": "8"
           },
           "i": {
             "type": "integer",
             "value": "9"
           },
           "j": {
             "type": "integer",
             "value": "10"
           },
           "k": {
             "type": "integer",
             "value": "11"
           },
           "l": {
             "type": "integer",
             "value": "12"
           }
         },
         "many": {
           "dots": {
             "here": {
               "dot": {
                 "dot": {
                   "dot": {
                     "type": "integer",
                     "value": "42"
                   }
                 }
               }
             }
           }
         },
         "name": {
           "first": {
             "type": "string",
             "value": "Arthur"
           },
           "last": {
             "type": "string",
             "value": "Dent"
           }
         },
         "tbl": {
           "a": {
             "b": {
               "c": {
                 "type": "float",
                 "value": "42.666"
               }
             }
           }
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/key/empty[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\x01' in string literal

[1m     input sent to parser-cmd:[0m
       "" = "blank"

[1m     output from parser-cmd (stdout):[0m
       {
       	"": {
       	"type": "string",
       	"value": "blank"
       }
       }

[1m     want:[0m
       {
         "": {
           "type": "string",
           "value": "blank"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/key/escapes[0m
[1;38;5;0;48;5;224m [0m    error: Allocation failure, Error=error.BadSyntax
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 1

[1m     input sent to parser-cmd:[0m
       "\n" = "newline"
       "\u00c0" = "latin capital letter A with grave"
       "\"" = "just a quote"
       
       ["backsp\b\b"]
       
       ["\"quoted\""]
       quote = true
       
       ["a.b"."\u00c0"]

[1m     output from parser-cmd (stderr):[0m
       error: Allocation failure, Error=error.BadSyntax
       
       Exit 1

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/key/quoted-unicode[0m
[1;38;5;0;48;5;224m [0m    error: Allocation failure, Error=error.DupKey
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 1

[1m     input sent to parser-cmd:[0m
       
       "\u0000" = "null"
       '\u0000' = "different key"
       "\u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff" = "escaped key"
       
       "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø" = "basic key"
       'l ~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø' = "literal key"

[1m     output from parser-cmd (stderr):[0m
       error: Allocation failure, Error=error.DupKey
       
       Exit 1

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/key/space[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\t' in string literal

[1m     input sent to parser-cmd:[0m
       # Keep whitespace inside quotes keys at all positions.
       "a b"   = 1
       " c d " = 2
       
       [ " tbl " ]
       "\ttab\ttab\t" = "tab"

[1m     output from parser-cmd (stdout):[0m
       {
       	" tbl ": {
       	"\ttab	tab	": {
       	"type": "string",
       	"value": "tab"
       }
       }
       ,
       	" c d ": {
       	"type": "integer",
       	"value": "2"
       },
       	"a b": {
       	"type": "integer",
       	"value": "1"
       }
       }

[1m     want:[0m
       {
         " c d ": {
           "type": "integer",
           "value": "2"
         },
         " tbl ": {
           "\ttab\ttab\t": {
             "type": "string",
             "value": "tab"
           }
         },
         "a b": {
           "type": "integer",
           "value": "1"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/array-of-tables-0[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '}' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       [[products]]
       name = "Hammer"
       sku = 738594937
       
       [[products]]  # empty table within the array
       
       [[products]]
       name = "Nail"
       sku = 284758393
       
       color = "gray"

[1m     output from parser-cmd (stdout):[0m
       {
       	"products": 
       }

[1m     want:[0m
       {
         "products": [
           {
             "name": {
               "type": "string",
               "value": "Hammer"
             },
             "sku": {
               "type": "integer",
               "value": "738594937"
             }
           },
           {},
           {
             "color": {
               "type": "string",
               "value": "gray"
             },
             "name": {
               "type": "string",
               "value": "Nail"
             },
             "sku": {
               "type": "integer",
               "value": "284758393"
             }
           }
         ]
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/array-of-tables-1[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '}' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       [[fruits]]
       name = "apple"
       
       [fruits.physical]  # subtable
       color = "red"
       shape = "round"
       
       [[fruits.varieties]]  # nested array of tables
       name = "red delicious"
       
       [[fruits.varieties]]
       name = "granny smith"
       
       
       [[fruits]]
       name = "banana"
       
       [[fruits.varieties]]
       name = "plantain"

[1m     output from parser-cmd (stdout):[0m
       {
       	"fruits": 
       }

[1m     want:[0m
       {
         "fruits": [
           {
             "name": {
               "type": "string",
               "value": "apple"
             },
             "physical": {
               "color": {
                 "type": "string",
                 "value": "red"
               },
               "shape": {
                 "type": "string",
                 "value": "round"
               }
             },
             "varieties": [
               {
                 "name": {
                   "type": "string",
                   "value": "red delicious"
                 }
               },
               {
                 "name": {
                   "type": "string",
                   "value": "granny smith"
                 }
               }
             ]
           },
           {
             "name": {
               "type": "string",
               "value": "banana"
             },
             "varieties": [
               {
                 "name": {
                   "type": "string",
                   "value": "plantain"
                 }
               }
             ]
           }
         ]
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/keys-1[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character 'v' after object key

[1m     input sent to parser-cmd:[0m
       "127.0.0.1" = "value"
       "character encoding" = "value"
       " é«ù û" = "value"
       'key2' = "value"
       'quoted "value"' = "value"

[1m     output from parser-cmd (stdout):[0m
       {
       	"character encoding": {
       	"type": "string",
       	"value": "value"
       },
       	"key2": {
       	"type": "string",
       	"value": "value"
       },
       	" é«ù û": {
       	"type": "string",
       	"value": "value"
       },
       	"127.0.0.1": {
       	"type": "string",
       	"value": "value"
       },
       	"quoted "value"": {
       	"type": "string",
       	"value": "value"
       }
       }

[1m     want:[0m
       {
         "127.0.0.1": {
           "type": "string",
           "value": "value"
         },
         "character encoding": {
           "type": "string",
           "value": "value"
         },
         "key2": {
           "type": "string",
           "value": "value"
         },
         "quoted \"value\"": {
           "type": "string",
           "value": "value"
         },
         " é«ù û": {
           "type": "string",
           "value": "value"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/local-date-0[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = null }

[1m     input sent to parser-cmd:[0m
       ld1 = 1979-05-27

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = null }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/local-date-time-0[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = null } }
[1;38;5;0;48;5;224m [0m    Segmentation fault at address 0xffffffffffffffff
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x9b43bff60f in ??? (???)
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\io\writer.zig:23:40: 0x7ff7fdc511c4 in writeAll (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                    index += try self.write(bytes[index..]);
[1;38;5;0;48;5;224m [0m                                           ^
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\fmt.zig:1026:13: 0x7ff7fdc7a7dd in formatBuf__anon_9778 (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                return writer.writeAll(buf);
[1;38;5;0;48;5;224m [0m                ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:141:48: 0x7ff7fdc4a51b in jsonStringifyValue__anon_5458 (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                    value_string = try fmt.bufPrint(
[1;38;5;0;48;5;224m [0m                                                   ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:79:39: 0x7ff7fdc4305b in jsonStringifyTable (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                else => jsonStringifyValue(e.value_ptr.*, wr) catch return error.JsonStringifyError,
[1;38;5;0;48;5;224m [0m                                          ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:32:28: 0x7ff7fdc42be7 in main (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m        const json_out = toJson(allocator, parsed_table) catch |e| {
[1;38;5;0;48;5;224m [0m                               ^
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\start.zig:337:41: 0x7ff7fdc4100d in WinStartup (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m        std.debug.maybeEnableSegfaultHandler();
[1;38;5;0;48;5;224m [0m                                            ^
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x7fff13e07343 in ??? (KERNEL32.DLL)
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x7fff15b426b0 in ??? (ntdll.dll)
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 3

[1m     input sent to parser-cmd:[0m
       ldt1 = 1979-05-27T07:32:00
       ldt2 = 1979-05-27T00:32:00.999999

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = null } }
       Segmentation fault at address 0xffffffffffffffff
       ???:?:?: 0x9b43bff60f in ??? (???)
       D:\Software\zig\lib\std\io\writer.zig:23:40: 0x7ff7fdc511c4 in writeAll (test-parser.exe.obj)
                       index += try self.write(bytes[index..]);
                                              ^
       D:\Software\zig\lib\std\fmt.zig:1026:13: 0x7ff7fdc7a7dd in formatBuf__anon_9778 (test-parser.exe.obj)
                   return writer.writeAll(buf);
                   ^
       E:\Code\Zig\toml\tests\test-parser.zig:141:48: 0x7ff7fdc4a51b in jsonStringifyValue__anon_5458 (test-parser.exe.obj)
                       value_string = try fmt.bufPrint(
                                                      ^
       E:\Code\Zig\toml\tests\test-parser.zig:79:39: 0x7ff7fdc4305b in jsonStringifyTable (test-parser.exe.obj)
                   else => jsonStringifyValue(e.value_ptr.*, wr) catch return error.JsonStringifyError,
                                             ^
       E:\Code\Zig\toml\tests\test-parser.zig:32:28: 0x7ff7fdc42be7 in main (test-parser.exe.obj)
           const json_out = toJson(allocator, parsed_table) catch |e| {
                                  ^
       D:\Software\zig\lib\std\start.zig:337:41: 0x7ff7fdc4100d in WinStartup (test-parser.exe.obj)
           std.debug.maybeEnableSegfaultHandler();
                                               ^
       ???:?:?: 0x7fff13e07343 in ??? (KERNEL32.DLL)
       ???:?:?: 0x7fff15b426b0 in ??? (ntdll.dll)
       
       Exit 3

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/local-time-0[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = null, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = null } }
[1;38;5;0;48;5;224m [0m    Segmentation fault at address 0xffffffffffffffff
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x1e53bff69f in ??? (???)
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\io\writer.zig:23:40: 0x7ff7fdc511c4 in writeAll (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                    index += try self.write(bytes[index..]);
[1;38;5;0;48;5;224m [0m                                           ^
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\fmt.zig:1026:13: 0x7ff7fdc7a7dd in formatBuf__anon_9778 (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                return writer.writeAll(buf);
[1;38;5;0;48;5;224m [0m                ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:169:34: 0x7ff7fdc4af8d in jsonStringifyValue__anon_5458 (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                            offset = try fmt.bufPrint(&offset_buffer, "Z", .{});
[1;38;5;0;48;5;224m [0m                                     ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:79:39: 0x7ff7fdc4305b in jsonStringifyTable (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m                else => jsonStringifyValue(e.value_ptr.*, wr) catch return error.JsonStringifyError,
[1;38;5;0;48;5;224m [0m                                          ^
[1;38;5;0;48;5;224m [0m    E:\Code\Zig\toml\tests\test-parser.zig:32:28: 0x7ff7fdc42be7 in main (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m        const json_out = toJson(allocator, parsed_table) catch |e| {
[1;38;5;0;48;5;224m [0m                               ^
[1;38;5;0;48;5;224m [0m    D:\Software\zig\lib\std\start.zig:337:41: 0x7ff7fdc4100d in WinStartup (test-parser.exe.obj)
[1;38;5;0;48;5;224m [0m        std.debug.maybeEnableSegfaultHandler();
[1;38;5;0;48;5;224m [0m                                            ^
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x7fff13e07343 in ??? (KERNEL32.DLL)
[1;38;5;0;48;5;224m [0m    ???:?:?: 0x7fff15b426b0 in ??? (ntdll.dll)
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 3

[1m     input sent to parser-cmd:[0m
       lt1 = 07:32:00
       lt2 = 00:32:00.999999

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = null, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = null } }
       Segmentation fault at address 0xffffffffffffffff
       ???:?:?: 0x1e53bff69f in ??? (???)
       D:\Software\zig\lib\std\io\writer.zig:23:40: 0x7ff7fdc511c4 in writeAll (test-parser.exe.obj)
                       index += try self.write(bytes[index..]);
                                              ^
       D:\Software\zig\lib\std\fmt.zig:1026:13: 0x7ff7fdc7a7dd in formatBuf__anon_9778 (test-parser.exe.obj)
                   return writer.writeAll(buf);
                   ^
       E:\Code\Zig\toml\tests\test-parser.zig:169:34: 0x7ff7fdc4af8d in jsonStringifyValue__anon_5458 (test-parser.exe.obj)
                               offset = try fmt.bufPrint(&offset_buffer, "Z", .{});
                                        ^
       E:\Code\Zig\toml\tests\test-parser.zig:79:39: 0x7ff7fdc4305b in jsonStringifyTable (test-parser.exe.obj)
                   else => jsonStringifyValue(e.value_ptr.*, wr) catch return error.JsonStringifyError,
                                             ^
       E:\Code\Zig\toml\tests\test-parser.zig:32:28: 0x7ff7fdc42be7 in main (test-parser.exe.obj)
           const json_out = toJson(allocator, parsed_table) catch |e| {
                                  ^
       D:\Software\zig\lib\std\start.zig:337:41: 0x7ff7fdc4100d in WinStartup (test-parser.exe.obj)
           std.debug.maybeEnableSegfaultHandler();
                                               ^
       ???:?:?: 0x7fff13e07343 in ??? (KERNEL32.DLL)
       ???:?:?: 0x7fff15b426b0 in ??? (ntdll.dll)
       
       Exit 3

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/offset-date-time-0[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 0, .minute = 32, .second = 0, .nano_sec = 999999000, .offset = date_time.TimeOffset{ .z = false, .minutes = 420 } } }
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 0, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = 420 } } }

[1m     input sent to parser-cmd:[0m
       odt1 = 1979-05-27T07:32:00Z
       odt2 = 1979-05-27T00:32:00-07:00
       odt3 = 1979-05-27T00:32:00.999999-07:00

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 0, .minute = 32, .second = 0, .nano_sec = 999999000, .offset = date_time.TimeOffset{ .z = false, .minutes = 420 } } }
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 0, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = 420 } } }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/offset-date-time-1[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     input sent to parser-cmd:[0m
       odt4 = 1979-05-27 07:32:00Z

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = true, .minutes = 0 } } }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/string-0[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\t' in string literal

[1m     input sent to parser-cmd:[0m
       str = "I'm a string. \"You can quote me\". Name\tJos\u00E9\nLocation\tSF."

[1m     output from parser-cmd (stdout):[0m
       {
       	"str": {
       	"type": "string",
       	"value": "I'm a string. \"You can quote me\". Name	Jos√©
       Location	SF."
       }
       }

[1m     want:[0m
       {
         "str": {
           "type": "string",
           "value": "I'm a string. \"You can quote me\". Name\tJos√©\nLocation\tSF."
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/string-1[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\n' in string literal

[1m     input sent to parser-cmd:[0m
       str1 = """
       Roses are red
       Violets are blue"""

[1m     output from parser-cmd (stdout):[0m
       {
       	"str1": {
       	"type": "string",
       	"value": "Roses are red
       Violets are blue"
       }
       }

[1m     want:[0m
       {
         "str1": {
           "type": "string",
           "value": "Roses are red\nViolets are blue"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/string-2[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\n' in string literal

[1m     input sent to parser-cmd:[0m
       # On a Unix system, the above multi-line string will most likely be the same as:
       str2 = "Roses are red\nViolets are blue"
       
       # On a Windows system, it will most likely be equivalent to:
       str3 = "Roses are red\r\nViolets are blue"

[1m     output from parser-cmd (stdout):[0m
       {
       	"str2": {
       	"type": "string",
       	"value": "Roses are red
       Violets are blue"
       },
       	"str3": {
       	"type": "string",
       	"value": "Roses are red
       Violets are blue"
       }
       }

[1m     want:[0m
       {
         "str2": {
           "type": "string",
           "value": "Roses are red\nViolets are blue"
         },
         "str3": {
           "type": "string",
           "value": "Roses are red\r\nViolets are blue"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/string-4[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '"' after object key:value pair

[1m     input sent to parser-cmd:[0m
       str4 = """Here are two quotation marks: "". Simple enough."""
       # str5 = """Here are three quotation marks: """."""  # INVALID
       str5 = """Here are three quotation marks: ""\"."""
       str6 = """Here are fifteen quotation marks: ""\"""\"""\"""\"""\"."""
       
       # "This," she said, "is just a pointless statement."
       str7 = """"This," she said, "is just a pointless statement.""""

[1m     output from parser-cmd (stdout):[0m
       {
       	"str6": {
       	"type": "string",
       	"value": "Here are fifteen quotation marks: ""\"""\"""\"""\"""\"."
       },
       	"str7": {
       	"type": "string",
       	"value": ""This," she said, "is just a pointless statement.""
       },
       	"str5": {
       	"type": "string",
       	"value": "Here are three quotation marks: ""\"."
       },
       	"str4": {
       	"type": "string",
       	"value": "Here are two quotation marks: "". Simple enough."
       }
       }

[1m     want:[0m
       {
         "str4": {
           "type": "string",
           "value": "Here are two quotation marks: \"\". Simple enough."
         },
         "str5": {
           "type": "string",
           "value": "Here are three quotation marks: \"\"\"."
         },
         "str6": {
           "type": "string",
           "value": "Here are fifteen quotation marks: \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"."
         },
         "str7": {
           "type": "string",
           "value": "\"This,\" she said, \"is just a pointless statement.\""
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/string-5[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character 'i' in string escape code

[1m     input sent to parser-cmd:[0m
       # What you see is what you get.
       winpath  = 'C:\Users\nodejs\templates'
       winpath2 = '\\ServerX\admin$\system32\'
       quoted   = 'Tom "Dubs" Preston-Werner'
       regex    = '<\i\c*\s*>'

[1m     output from parser-cmd (stdout):[0m
       {
       	"regex": {
       	"type": "string",
       	"value": "<\i\c*\s*>"
       },
       	"winpath": {
       	"type": "string",
       	"value": "C:\Users\nodejs\templates"
       },
       	"quoted": {
       	"type": "string",
       	"value": "Tom "Dubs" Preston-Werner"
       },
       	"winpath2": {
       	"type": "string",
       	"value": "\\ServerX\admin$\system32\"
       }
       }

[1m     want:[0m
       {
         "quoted": {
           "type": "string",
           "value": "Tom \"Dubs\" Preston-Werner"
         },
         "regex": {
           "type": "string",
           "value": "\u003c\\i\\c*\\s*\u003e"
         },
         "winpath": {
           "type": "string",
           "value": "C:\\Users\\nodejs\\templates"
         },
         "winpath2": {
           "type": "string",
           "value": "\\\\ServerX\\admin$\\system32\\"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/string-6[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character 'd' in string escape code

[1m     input sent to parser-cmd:[0m
       regex2 = '''I [dw]on't need \d{2} apples'''
       lines  = '''
       The first newline is
       trimmed in raw strings.
          All other whitespace
          is preserved.
       '''

[1m     output from parser-cmd (stdout):[0m
       {
       	"regex2": {
       	"type": "string",
       	"value": "I [dw]on't need \d{2} apples"
       },
       	"lines": {
       	"type": "string",
       	"value": "The first newline is
       trimmed in raw strings.
          All other whitespace
          is preserved.
       "
       }
       }

[1m     want:[0m
       {
         "lines": {
           "type": "string",
           "value": "The first newline is\ntrimmed in raw strings.\n   All other whitespace\n   is preserved.\n"
         },
         "regex2": {
           "type": "string",
           "value": "I [dw]on't need \\d{2} apples"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/string-7[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '"' after object key:value pair

[1m     input sent to parser-cmd:[0m
       quot15 = '''Here are fifteen quotation marks: """""""""""""""'''
       
       # apos15 = '''Here are fifteen apostrophes: ''''''''''''''''''  # INVALID
       apos15 = "Here are fifteen apostrophes: '''''''''''''''"
       
       # 'That,' she said, 'is still pointless.'
       str = ''''That,' she said, 'is still pointless.''''

[1m     output from parser-cmd (stdout):[0m
       {
       	"str": {
       	"type": "string",
       	"value": "'That,' she said, 'is still pointless.'"
       },
       	"quot15": {
       	"type": "string",
       	"value": "Here are fifteen quotation marks: """"""""""""""""
       },
       	"apos15": {
       	"type": "string",
       	"value": "Here are fifteen apostrophes: '''''''''''''''"
       }
       }

[1m     want:[0m
       {
         "apos15": {
           "type": "string",
           "value": "Here are fifteen apostrophes: '''''''''''''''"
         },
         "quot15": {
           "type": "string",
           "value": "Here are fifteen quotation marks: \"\"\"\"\"\"\"\"\"\"\"\"\"\"\""
         },
         "str": {
           "type": "string",
           "value": "'That,' she said, 'is still pointless.'"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec/table-7[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1999, .month = 8, .day = 4 }, .time = null }

[1m     input sent to parser-cmd:[0m
       # Top-level table begins.
       name = "Fido"
       breed = "pug"
       
       # Top-level table ends.
       [owner]
       name = "Regina Dogman"
       member_since = 1999-08-04

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1999, .month = 8, .day = 4 }, .time = null }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec-example-1-compact[0m
[1;38;5;0;48;5;224m [0m    error: Allocation failure, Error=error.BadSyntax
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 1

[1m     input sent to parser-cmd:[0m
       #Useless spaces eliminated.
       title="TOML Example"
       [owner]
       name="Lance Uppercut"
       dob=1979-05-27T07:32:00-08:00#First class dates
       [database]
       server="192.168.1.1"
       ports=[8001,8001,8002]
       connection_max=5000
       enabled=true
       [servers]
       [servers.alpha]
       ip="10.0.0.1"
       dc="eqdc10"
       [servers.beta]
       ip="10.0.0.2"
       dc="eqdc10"
       [clients]
       data=[["gamma","delta"],[1,2]]
       hosts=[
       "alpha",
       "omega"
       ]

[1m     output from parser-cmd (stderr):[0m
       error: Allocation failure, Error=error.BadSyntax
       
       Exit 1

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/spec-example-1[0m
[1;38;5;0;48;5;224m [0m    TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = 480 } } }

[1m     input sent to parser-cmd:[0m
       # This is a TOML document. Boom.
       
       title = "TOML Example"
       
       [owner]
       name = "Lance Uppercut"
       dob = 1979-05-27T07:32:00-08:00 # First class dates? Why not?
       
       [database]
       server = "192.168.1.1"
       ports = [ 8001, 8001, 8002 ]
       connection_max = 5000
       enabled = true
       
       [servers]
       
         # You can indent as you please. Tabs or spaces. TOML don't care.
         [servers.alpha]
         ip = "10.0.0.1"
         dc = "eqdc10"
       
         [servers.beta]
         ip = "10.0.0.2"
         dc = "eqdc10"
       
       [clients]
       data = [ ["gamma", "delta"], [1, 2] ]
       
       # Line breaks are OK when inside arrays
       hosts = [
         "alpha",
         "omega"
       ]

[1m     output from parser-cmd (stderr):[0m
       TS=date_time.DateTime{ .date = date_time.Date{ .year = 1979, .month = 5, .day = 27 }, .time = date_time.Time{ .hour = 7, .minute = 32, .second = 0, .nano_sec = 0, .offset = date_time.TimeOffset{ .z = false, .minutes = 480 } } }

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/double-quote-escape[0m
[1;38;5;0;48;5;224m [0m    error: Allocation failure, Error=error.BadSyntax
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 1

[1m     input sent to parser-cmd:[0m
       test = "\"one\""

[1m     output from parser-cmd (stderr):[0m
       error: Allocation failure, Error=error.BadSyntax
       
       Exit 1

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/escape-tricky[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '"' after object key:value pair

[1m     input sent to parser-cmd:[0m
       end_esc = "String does not end here\" but ends here\\"
       lit_end_esc = 'String ends here\'
       
       multiline_unicode = """
       \u00a0"""
       
       multiline_not_unicode = """
       \\u0041"""
       
       multiline_end_esc = """When will it end? \"""...""\" should be here\""""
       
       lit_multiline_not_unicode = '''
       \u007f'''
       
       lit_multiline_end = '''There is no escape\'''

[1m     output from parser-cmd (stdout):[0m
       {
       	"multiline_unicode": {
       	"type": "string",
       	"value": "¬†"
       },
       	"multiline_end_esc": {
       	"type": "string",
       	"value": "When will it end? \"""...""\" should be here\""
       },
       	"lit_multiline_not_unicode": {
       	"type": "string",
       	"value": "\u007f"
       },
       	"lit_multiline_end": {
       	"type": "string",
       	"value": "There is no escape\"
       },
       	"end_esc": {
       	"type": "string",
       	"value": "String does not end here\" but ends here\\"
       },
       	"multiline_not_unicode": {
       	"type": "string",
       	"value": "\\u0041"
       },
       	"lit_end_esc": {
       	"type": "string",
       	"value": "String ends here\"
       }
       }

[1m     want:[0m
       {
         "end_esc": {
           "type": "string",
           "value": "String does not end here\" but ends here\\"
         },
         "lit_end_esc": {
           "type": "string",
           "value": "String ends here\\"
         },
         "lit_multiline_end": {
           "type": "string",
           "value": "There is no escape\\"
         },
         "lit_multiline_not_unicode": {
           "type": "string",
           "value": "\\u007f"
         },
         "multiline_end_esc": {
           "type": "string",
           "value": "When will it end? \"\"\"...\"\"\" should be here\""
         },
         "multiline_not_unicode": {
           "type": "string",
           "value": "\\u0041"
         },
         "multiline_unicode": {
           "type": "string",
           "value": "¬†"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/escaped-escape[0m
[1;38;5;0;48;5;224m [0m    error: Allocation failure, Error=error.BadStringEscSeq
[1;38;5;0;48;5;224m [0m    
[1;38;5;0;48;5;224m [0m    Exit 1

[1m     input sent to parser-cmd:[0m
       answer = "\\x64"

[1m     output from parser-cmd (stderr):[0m
       error: Allocation failure, Error=error.BadStringEscSeq
       
       Exit 1

[1m     want:[0m
          <empty>

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/escapes[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\t' in string literal

[1m     input sent to parser-cmd:[0m
       backspace = "This string has a \b backspace character."
       tab = "This string has a \t tab character."
       newline = "This string has a \n new line character."
       formfeed = "This string has a \f form feed character."
       carriage = "This string has a \r carriage return character."
       quote = "This string has a \" quote character."
       backslash = "This string has a \\ backslash character."
       notunicode1 = "This string does not have a unicode \\u escape."
       notunicode2 = "This string does not have a unicode \u005Cu escape."
       notunicode3 = "This string does not have a unicode \\u0075 escape."
       notunicode4 = "This string does not have a unicode \\\u0075 escape."
       delete = "This string has a \u007F delete control code."
       unitseparator = "This string has a \u001F unit separator control code."

[1m     output from parser-cmd (stdout):[0m
       {
       	"delete": {
       	"type": "string",
       	"value": "This string has a  delete control code."
       },
       	"tab": {
       	"type": "string",
       	"value": "This string has a 	 tab character."
       },
       	"backslash": {
       	"type": "string",
       	"value": "This string has a \\ backslash character."
       },
       	"notunicode2": {
       	"type": "string",
       	"value": "This string does not have a unicode \u escape."
       },
       	"notunicode4": {
       	"type": "string",
       	"value": "This string does not have a unicode \\u escape."
       },
       	"notunicode3": {
       	"type": "string",
       	"value": "This string does not have a unicode \\u0075 escape."
       },
       	"newline": {
       	"type": "string",
       	"value": "This string has a 
        new line character."
       },
       	"unitseparator": {
       	"type": "string",
       	"value": "This string has a  unit separator control code."
       },
       	"backspace": {
       	"type": "string",
       	"value": "This string has a  backspace character."
       },
       	"notunicode1": {
       	"type": "string",
       	"value": "This string does not have a unicode \\u escape."
       },
       	"carriage": {
       	"type": "string",
       	"value": "This string has a  carriage return character."
       },
       	"quote": {
       	"type": "string",
       	"value": "This string has a \" quote character."
       },
       	"formfeed": {
       	"type": "string",
       	"value": "This string has a  form feed character."
       }
       }

[1m     want:[0m
       {
         "backslash": {
           "type": "string",
           "value": "This string has a \\ backslash character."
         },
         "backspace": {
           "type": "string",
           "value": "This string has a \u0008 backspace character."
         },
         "carriage": {
           "type": "string",
           "value": "This string has a \r carriage return character."
         },
         "delete": {
           "type": "string",
           "value": "This string has a  delete control code."
         },
         "formfeed": {
           "type": "string",
           "value": "This string has a \u000c form feed character."
         },
         "newline": {
           "type": "string",
           "value": "This string has a \n new line character."
         },
         "notunicode1": {
           "type": "string",
           "value": "This string does not have a unicode \\u escape."
         },
         "notunicode2": {
           "type": "string",
           "value": "This string does not have a unicode \\u escape."
         },
         "notunicode3": {
           "type": "string",
           "value": "This string does not have a unicode \\u0075 escape."
         },
         "notunicode4": {
           "type": "string",
           "value": "This string does not have a unicode \\u escape."
         },
         "quote": {
           "type": "string",
           "value": "This string has a \" quote character."
         },
         "tab": {
           "type": "string",
           "value": "This string has a \t tab character."
         },
         "unitseparator": {
           "type": "string",
           "value": "This string has a \u001f unit separator control code."
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/multiline-quotes[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character 'o' after object key:value pair

[1m     input sent to parser-cmd:[0m
       # Make sure that quotes inside multiline strings are allowed, including right
       # after the opening '''/""" and before the closing '''/"""
       
       lit_one = ''''one quote''''
       lit_two = '''''two quotes'''''
       lit_one_space = ''' 'one quote' '''
       lit_two_space = ''' ''two quotes'' '''
       
       one = """"one quote""""
       two = """""two quotes"""""
       one_space = """ "one quote" """
       two_space = """ ""two quotes"" """
       
       mismatch1 = """aaa'''bbb"""
       mismatch2 = '''aaa"""bbb'''
       
       # Three opening """, then one escaped ", then two "" (allowed), and then three
       # closing """
       escaped = """lol\""""""

[1m     output from parser-cmd (stdout):[0m
       {
       	"one_space": {
       	"type": "string",
       	"value": " "one quote" "
       },
       	"lit_two": {
       	"type": "string",
       	"value": "''two quotes''"
       },
       	"escaped": {
       	"type": "string",
       	"value": "lol\""""
       },
       	"one": {
       	"type": "string",
       	"value": ""one quote""
       },
       	"mismatch2": {
       	"type": "string",
       	"value": "aaa"""bbb"
       },
       	"lit_one": {
       	"type": "string",
       	"value": "'one quote'"
       },
       	"lit_two_space": {
       	"type": "string",
       	"value": " ''two quotes'' "
       },
       	"mismatch1": {
       	"type": "string",
       	"value": "aaa'''bbb"
       },
       	"two_space": {
       	"type": "string",
       	"value": " ""two quotes"" "
       },
       	"lit_one_space": {
       	"type": "string",
       	"value": " 'one quote' "
       },
       	"two": {
       	"type": "string",
       	"value": """two quotes"""
       }
       }

[1m     want:[0m
       {
         "escaped": {
           "type": "string",
           "value": "lol\"\"\""
         },
         "lit_one": {
           "type": "string",
           "value": "'one quote'"
         },
         "lit_one_space": {
           "type": "string",
           "value": " 'one quote' "
         },
         "lit_two": {
           "type": "string",
           "value": "''two quotes''"
         },
         "lit_two_space": {
           "type": "string",
           "value": " ''two quotes'' "
         },
         "mismatch1": {
           "type": "string",
           "value": "aaa'''bbb"
         },
         "mismatch2": {
           "type": "string",
           "value": "aaa\"\"\"bbb"
         },
         "one": {
           "type": "string",
           "value": "\"one quote\""
         },
         "one_space": {
           "type": "string",
           "value": " \"one quote\" "
         },
         "two": {
           "type": "string",
           "value": "\"\"two quotes\"\""
         },
         "two_space": {
           "type": "string",
           "value": " \"\"two quotes\"\" "
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/multiline[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\n' in string literal

[1m     input sent to parser-cmd:[0m
       # NOTE: this file includes some literal tab characters.
       
       multiline_empty_one = """"""
       
       # A newline immediately following the opening delimiter will be trimmed.
       multiline_empty_two = """
       """
       
       # \ at the end of line trims newlines as well; note that last \ is followed by
       # two spaces, which are ignored.
       multiline_empty_three = """\
           """
       multiline_empty_four = """\
          \
          \  
          """
       
       equivalent_one = "The quick brown fox jumps over the lazy dog."
       equivalent_two = """
       The quick brown \
       
       
         fox jumps over \
           the lazy dog."""
       
       equivalent_three = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """
       
       whitespace-after-bs = """\
              The quick brown \
              fox jumps over \   
              the lazy dog.\	
              """
       
       no-space = """a\
           b"""
       
       # Has tab character.
       keep-ws-before = """a   	\
          b"""
       
       escape-bs-1 = """a \\
       b"""
       
       escape-bs-2 = """a \\\
       b"""
       
       escape-bs-3 = """a \\\\
         b"""

[1m     output from parser-cmd (stdout):[0m
       {
       	"multiline_empty_four": {
       	"type": "string",
       	"value": ""
       },
       	"no-space": {
       	"type": "string",
       	"value": "ab"
       },
       	"multiline_empty_three": {
       	"type": "string",
       	"value": ""
       },
       	"escape-bs-1": {
       	"type": "string",
       	"value": "a \\
       b"
       },
       	"equivalent_one": {
       	"type": "string",
       	"value": "The quick brown fox jumps over the lazy dog."
       },
       	"equivalent_three": {
       	"type": "string",
       	"value": "The quick brown fox jumps over the lazy dog."
       },
       	"whitespace-after-bs": {
       	"type": "string",
       	"value": "The quick brown fox jumps over the lazy dog."
       },
       	"escape-bs-3": {
       	"type": "string",
       	"value": "a \\\\
         b"
       },
       	"multiline_empty_one": {
       	"type": "string",
       	"value": ""
       },
       	"multiline_empty_two": {
       	"type": "string",
       	"value": ""
       },
       	"escape-bs-2": {
       	"type": "string",
       	"value": "a \\b"
       },
       	"equivalent_two": {
       	"type": "string",
       	"value": "The quick brown fox jumps over the lazy dog."
       },
       	"keep-ws-before": {
       	"type": "string",
       	"value": "a   	b"
       }
       }

[1m     want:[0m
       {
         "equivalent_one": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "equivalent_three": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "equivalent_two": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "escape-bs-1": {
           "type": "string",
           "value": "a \\\nb"
         },
         "escape-bs-2": {
           "type": "string",
           "value": "a \\b"
         },
         "escape-bs-3": {
           "type": "string",
           "value": "a \\\\\n  b"
         },
         "keep-ws-before": {
           "type": "string",
           "value": "a   \tb"
         },
         "multiline_empty_four": {
           "type": "string",
           "value": ""
         },
         "multiline_empty_one": {
           "type": "string",
           "value": ""
         },
         "multiline_empty_three": {
           "type": "string",
           "value": ""
         },
         "multiline_empty_two": {
           "type": "string",
           "value": ""
         },
         "no-space": {
           "type": "string",
           "value": "ab"
         },
         "whitespace-after-bs": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/nl[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\n' in string literal

[1m     input sent to parser-cmd:[0m
       nl_mid = "val\nue"
       nl_end = """value\n"""
       
       lit_nl_end = '''value\n'''
       lit_nl_mid = 'val\nue'
       lit_nl_uni = 'val\ue'

[1m     output from parser-cmd (stdout):[0m
       {
       	"lit_nl_mid": {
       	"type": "string",
       	"value": "val\nue"
       },
       	"nl_end": {
       	"type": "string",
       	"value": "value
       "
       },
       	"nl_mid": {
       	"type": "string",
       	"value": "val
       ue"
       },
       	"lit_nl_uni": {
       	"type": "string",
       	"value": "val\ue"
       },
       	"lit_nl_end": {
       	"type": "string",
       	"value": "value\n"
       }
       }

[1m     want:[0m
       {
         "lit_nl_end": {
           "type": "string",
           "value": "value\\n"
         },
         "lit_nl_mid": {
           "type": "string",
           "value": "val\\nue"
         },
         "lit_nl_uni": {
           "type": "string",
           "value": "val\\ue"
         },
         "nl_end": {
           "type": "string",
           "value": "value\n"
         },
         "nl_mid": {
           "type": "string",
           "value": "val\nue"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/quoted-unicode[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\b' in string literal

[1m     input sent to parser-cmd:[0m
       
       escaped_string = "\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff"
       not_escaped_string = '\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff'
       
       basic_string = "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
       literal_string = '~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø'

[1m     output from parser-cmd (stdout):[0m
       {
       	"escaped_string": {
       	"type": "string",
       	"value": "\u0000   A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
       },
       	"not_escaped_string": {
       	"type": "string",
       	"value": "\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff"
       },
       	"basic_string": {
       	"type": "string",
       	"value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
       },
       	"literal_string": {
       	"type": "string",
       	"value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
       }
       }

[1m     want:[0m
       {
         "escaped_string": {
           "type": "string",
           "value": "\u0000 \b \f A \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \ud800\udc00 \udbff\udfff"
         },
         "not_escaped_string": {
           "type": "string",
           "value": "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff"
         },
         "basic_string": {
           "type": "string",
           "value": "~ \u0080 \u00ff \ud7ff \ue000 \uffff \ud800\udc00 \udbff\udfff"
         },
         "literal_string": {
           "type": "string",
           "value": "~ \u0080 \u00ff \ud7ff \ue000 \uffff \ud800\udc00 \udbff\udfff"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/raw-multiline[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\n' in string literal

[1m     input sent to parser-cmd:[0m
       # Single ' should be allowed.
       oneline = '''This string has a ' quote character.'''
       
       # A newline immediately following the opening delimiter will be trimmed.
       firstnl = '''
       This string has a ' quote character.'''
       
       # All other whitespace and newline characters remain intact.
       multiline = '''
       This string
       has ' a quote character
       and more than
       one newline
       in it.'''
       
       # Tab character in literal string does not need to be escaped
       multiline_with_tab = '''First line
       	 Followed by a tab'''

[1m     output from parser-cmd (stdout):[0m
       {
       	"multiline": {
       	"type": "string",
       	"value": "This string
       has ' a quote character
       and more than
       one newline
       in it."
       },
       	"oneline": {
       	"type": "string",
       	"value": "This string has a ' quote character."
       },
       	"firstnl": {
       	"type": "string",
       	"value": "This string has a ' quote character."
       },
       	"multiline_with_tab": {
       	"type": "string",
       	"value": "First line
       	 Followed by a tab"
       }
       }

[1m     want:[0m
       {
         "firstnl": {
           "type": "string",
           "value": "This string has a ' quote character."
         },
         "multiline": {
           "type": "string",
           "value": "This string\nhas ' a quote character\nand more than\none newline\nin it."
         },
         "oneline": {
           "type": "string",
           "value": "This string has a ' quote character."
         },
         "multiline_with_tab": {
           "type": "string",
           "value": "First line\n\t Followed by a tab"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/raw[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\t' in string literal

[1m     input sent to parser-cmd:[0m
       backspace = 'This string has a \b backspace character.'
       tab = 'This string has a \t tab character.'
       unescaped_tab = 'This string has an 	 unescaped tab character.'
       newline = 'This string has a \n new line character.'
       formfeed = 'This string has a \f form feed character.'
       carriage = 'This string has a \r carriage return character.'
       slash = 'This string has a \/ slash character.'
       backslash = 'This string has a \\ backslash character.'

[1m     output from parser-cmd (stdout):[0m
       {
       	"backspace": {
       	"type": "string",
       	"value": "This string has a \b backspace character."
       },
       	"tab": {
       	"type": "string",
       	"value": "This string has a \t tab character."
       },
       	"unescaped_tab": {
       	"type": "string",
       	"value": "This string has an 	 unescaped tab character."
       },
       	"carriage": {
       	"type": "string",
       	"value": "This string has a \r carriage return character."
       },
       	"backslash": {
       	"type": "string",
       	"value": "This string has a \\ backslash character."
       },
       	"slash": {
       	"type": "string",
       	"value": "This string has a \/ slash character."
       },
       	"newline": {
       	"type": "string",
       	"value": "This string has a \n new line character."
       },
       	"formfeed": {
       	"type": "string",
       	"value": "This string has a \f form feed character."
       }
       }

[1m     want:[0m
       {
         "backslash": {
           "type": "string",
           "value": "This string has a \\\\ backslash character."
         },
         "backspace": {
           "type": "string",
           "value": "This string has a \\b backspace character."
         },
         "carriage": {
           "type": "string",
           "value": "This string has a \\r carriage return character."
         },
         "formfeed": {
           "type": "string",
           "value": "This string has a \\f form feed character."
         },
         "newline": {
           "type": "string",
           "value": "This string has a \\n new line character."
         },
         "slash": {
           "type": "string",
           "value": "This string has a \\/ slash character."
         },
         "tab": {
           "type": "string",
           "value": "This string has a \\t tab character."
         },
         "unescaped_tab": {
           "type": "string",
           "value": "This string has an \t unescaped tab character."
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/string/unicode-escape[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character 'U' in string escape code

[1m     input sent to parser-cmd:[0m
       answer4 = "\u03B4"
       answer8 = "\U000003B4"

[1m     output from parser-cmd (stdout):[0m
       {
       	"answer4": {
       	"type": "string",
       	"value": "\u03B4"
       },
       	"answer8": {
       	"type": "string",
       	"value": "\U000003B4"
       }
       }

[1m     want:[0m
       {
         "answer4": {
           "type": "string",
           "value": "Œ¥"
         },
         "answer8": {
           "type": "string",
           "value": "Œ¥"
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/table/array-implicit-and-explicit-after[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character ',' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       [[a.b]]
       x = 1
       
       [a]
       y = 2

[1m     output from parser-cmd (stdout):[0m
       {
       	"a": {
       	"b": ,
       	"y": {
       	"type": "integer",
       	"value": "2"
       }
       }
       
       }

[1m     want:[0m
       {
         "a": {
           "b": [
             {
               "x": {
                 "type": "integer",
                 "value": "1"
               }
             }
           ],
           "y": {
             "type": "integer",
             "value": "2"
           }
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/table/array-implicit[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '}' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       [[albums.songs]]
       name = "Glory Days"

[1m     output from parser-cmd (stdout):[0m
       {
       	"albums": {
       	"songs": 
       }
       
       }

[1m     want:[0m
       {
         "albums": {
           "songs": [
             {
               "name": {
                 "type": "string",
                 "value": "Glory Days"
               }
             }
           ]
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/table/array-many[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '}' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       [[people]]
       first_name = "Bruce"
       last_name = "Springsteen"
       
       [[people]]
       first_name = "Eric"
       last_name = "Clapton"
       
       [[people]]
       first_name = "Bob"
       last_name = "Seger"

[1m     output from parser-cmd (stdout):[0m
       {
       	"people": 
       }

[1m     want:[0m
       {
         "people": [
           {
             "first_name": {
               "type": "string",
               "value": "Bruce"
             },
             "last_name": {
               "type": "string",
               "value": "Springsteen"
             }
           },
           {
             "first_name": {
               "type": "string",
               "value": "Eric"
             },
             "last_name": {
               "type": "string",
               "value": "Clapton"
             }
           },
           {
             "first_name": {
               "type": "string",
               "value": "Bob"
             },
             "last_name": {
               "type": "string",
               "value": "Seger"
             }
           }
         ]
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/table/array-nest[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '}' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       [[albums]]
       name = "Born to Run"
       
         [[albums.songs]]
         name = "Jungleland"
       
         [[albums.songs]]
         name = "Meeting Across the River"
       
       [[albums]]
       name = "Born in the USA"
         
         [[albums.songs]]
         name = "Glory Days"
       
         [[albums.songs]]
         name = "Dancing in the Dark"

[1m     output from parser-cmd (stdout):[0m
       {
       	"albums": 
       }

[1m     want:[0m
       {
         "albums": [
           {
             "name": {
               "type": "string",
               "value": "Born to Run"
             },
             "songs": [
               {
                 "name": {
                   "type": "string",
                   "value": "Jungleland"
                 }
               },
               {
                 "name": {
                   "type": "string",
                   "value": "Meeting Across the River"
                 }
               }
             ]
           },
           {
             "name": {
               "type": "string",
               "value": "Born in the USA"
             },
             "songs": [
               {
                 "name": {
                   "type": "string",
                   "value": "Glory Days"
                 }
               },
               {
                 "name": {
                   "type": "string",
                   "value": "Dancing in the Dark"
                 }
               }
             ]
           }
         ]
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/table/array-one[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '}' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       [[people]]
       first_name = "Bruce"
       last_name = "Springsteen"

[1m     output from parser-cmd (stdout):[0m
       {
       	"people": 
       }

[1m     want:[0m
       {
         "people": [
           {
             "first_name": {
               "type": "string",
               "value": "Bruce"
             },
             "last_name": {
               "type": "string",
               "value": "Springsteen"
             }
           }
         ]
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/table/array-table-array[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '}' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       [[a]]
           [[a.b]]
               [a.b.c]
                   d = "val0"
           [[a.b]]
               [a.b.c]
                   d = "val1"

[1m     output from parser-cmd (stdout):[0m
       {
       	"a": 
       }

[1m     want:[0m
       {
         "a": [
           {
             "b": [
               {
                 "c": {
                   "d": {
                     "type": "string",
                     "value": "val0"
                   }
                 }
               },
               {
                 "c": {
                   "d": {
                     "type": "string",
                     "value": "val1"
                   }
                 }
               }
             ]
           }
         ]
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/table/array-within-dotted[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '}' looking for beginning of value

[1m     input sent to parser-cmd:[0m
       [fruit]
       apple.color = "red"
       
       [[fruit.apple.seeds]]
       size = 2

[1m     output from parser-cmd (stdout):[0m
       {
       	"fruit": {
       	"apple": {
       	"color": {
       	"type": "string",
       	"value": "red"
       },
       	"seeds": 
       }
       
       }
       
       }

[1m     want:[0m
       {
         "fruit": {
           "apple": {
             "color": {
               "type": "string",
               "value": "red"
             },
             "seeds": [
               {
                 "size": {
                   "type": "integer",
                   "value": "2"
                 }
               }
             ]
           }
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/table/empty-name[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character '\x01' in string literal

[1m     input sent to parser-cmd:[0m
       ['']
       x = 1
       
       ["".a]
       x = 2
       
       [a.'']
       x = 3

[1m     output from parser-cmd (stdout):[0m
       {
       	"a": {
       	"": {
       	"x": {
       	"type": "integer",
       	"value": "3"
       }
       }
       
       }
       ,
       	"": {
       	"x": {
       	"type": "integer",
       	"value": "1"
       },
       	"a": {
       	"x": {
       	"type": "integer",
       	"value": "2"
       }
       }
       
       }
       
       }

[1m     want:[0m
       {
         "": {
           "x": {
             "type": "integer",
             "value": "1"
           },
           "a": {
             "x": {
               "type": "integer",
               "value": "2"
             }
           }
         },
         "a": {
           "": {
             "x": {
               "type": "integer",
               "value": "3"
             }
           }
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1mvalid/table/with-literal-string[0m
[1;38;5;0;48;5;224m [0m    decode JSON output from parser:
[1;38;5;0;48;5;224m [0m      invalid character 'b' after object key

[1m     input sent to parser-cmd:[0m
       ['a']
       [a.'"b"']
       [a.'"b"'.c]
       answer = 42 

[1m     output from parser-cmd (stdout):[0m
       {
       	"a": {
       	""b"": {
       	"c": {
       	"answer": {
       	"type": "integer",
       	"value": "42"
       }
       }
       
       }
       
       }
       
       }

[1m     want:[0m
       {
         "a": {
           "\"b\"": {
             "c": {
               "answer": {
                 "type": "integer",
                 "value": "42"
               }
             }
           }
         }
       }

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/array/double-comma-1[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       array = [1,,2]

[1m     output from parser-cmd (stdout):[0m
       {
         "array": [
           {
             "type": "integer",
             "value": "1"
           },
           {
             "type": "integer",
             "value": "2"
           }
         ]
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/array/double-comma-2[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       array = [1,2,,]

[1m     output from parser-cmd (stdout):[0m
       {
         "array": [
           {
             "type": "integer",
             "value": "1"
           },
           {
             "type": "integer",
             "value": "2"
           }
         ]
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/control/bare-cr[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # The following line contains a single carriage return control character
       

[1m     output from parser-cmd (stdout):[0m
       {}

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/control/comment-cr[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       comment-cr = "Carriage return in comment" # a=1

[1m     output from parser-cmd (stdout):[0m
       {
         "comment-cr": {
           "type": "string",
           "value": "Carriage return in comment"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/control/comment-del[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       comment-del = "0x7f" # 

[1m     output from parser-cmd (stdout):[0m
       {
         "comment-del": {
           "type": "string",
           "value": "0x7f"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/control/comment-lf[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       comment-lf = "ctrl-P" # 

[1m     output from parser-cmd (stdout):[0m
       {
         "comment-lf": {
           "type": "string",
           "value": "ctrl-P"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/control/comment-null[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       comment-null = "null" #  

[1m     output from parser-cmd (stdout):[0m
       {
         "comment-null": {
           "type": "string",
           "value": "null"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/control/comment-us[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       comment-us = "ctrl-_" # 

[1m     output from parser-cmd (stdout):[0m
       {
         "comment-us": {
           "type": "string",
           "value": "ctrl-_"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/encoding/bad-codepoint[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # Invalid codepoint U+D800 : Ì†Ä

[1m     output from parser-cmd (stdout):[0m
       {}

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/encoding/bad-utf8-in-comment[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # √

[1m     output from parser-cmd (stdout):[0m
       {}

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/encoding/bad-utf8-in-multiline-literal[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # The following line contains an invalid UTF-8 sequence.
       bad = '''√'''

[1m     output from parser-cmd (stdout):[0m
       {
         "bad": {
           "type": "string",
           "value": "ÔøΩ"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/encoding/bad-utf8-in-multiline[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # The following line contains an invalid UTF-8 sequence.
       bad = """√"""

[1m     output from parser-cmd (stdout):[0m
       {
         "bad": {
           "type": "string",
           "value": "ÔøΩ"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/encoding/bad-utf8-in-string-literal[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # The following line contains an invalid UTF-8 sequence.
       bad = '√'

[1m     output from parser-cmd (stdout):[0m
       {
         "bad": {
           "type": "string",
           "value": "ÔøΩ"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/encoding/bad-utf8-in-string[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # The following line contains an invalid UTF-8 sequence.
       bad = "√"

[1m     output from parser-cmd (stdout):[0m
       {
         "bad": {
           "type": "string",
           "value": "ÔøΩ"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/float/inf-capital[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       v = Inf

[1m     output from parser-cmd (stdout):[0m
       {
         "v": {
           "type": "float",
           "value": "inf"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/float/leading-zero-neg[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       leading-zero-neg = -03.14

[1m     output from parser-cmd (stdout):[0m
       {
         "leading-zero-neg": {
           "type": "float",
           "value": "-3.14"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/float/leading-zero-plus[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       leading-zero-plus = +03.14

[1m     output from parser-cmd (stdout):[0m
       {
         "leading-zero-plus": {
           "type": "float",
           "value": "3.14"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/float/leading-zero[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       leading-zero = 03.14

[1m     output from parser-cmd (stdout):[0m
       {
         "leading-zero": {
           "type": "float",
           "value": "3.14"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/float/nan-capital[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       v = NaN

[1m     output from parser-cmd (stdout):[0m
       {
         "v": {
           "type": "float",
           "value": "nan"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/capital-bin[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       capital-bin = 0B0

[1m     output from parser-cmd (stdout):[0m
       {
         "capital-bin": {
           "type": "integer",
           "value": "0"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/capital-hex[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       capital-hex = 0X1

[1m     output from parser-cmd (stdout):[0m
       {
         "capital-hex": {
           "type": "integer",
           "value": "1"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/capital-oct[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       capital-oct = 0O0

[1m     output from parser-cmd (stdout):[0m
       {
         "capital-oct": {
           "type": "integer",
           "value": "0"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/double-us[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       double-us = 1__23

[1m     output from parser-cmd (stdout):[0m
       {
         "double-us": {
           "type": "integer",
           "value": "123"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/leading-zero-1[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       leading-zero-1 = 01

[1m     output from parser-cmd (stdout):[0m
       {
         "leading-zero-1": {
           "type": "integer",
           "value": "1"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/leading-zero-2[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       leading-zero-2 = 00

[1m     output from parser-cmd (stdout):[0m
       {
         "leading-zero-2": {
           "type": "integer",
           "value": "0"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/leading-zero-3[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       leading-zero-3 = 0_0

[1m     output from parser-cmd (stdout):[0m
       {
         "leading-zero-3": {
           "type": "integer",
           "value": "0"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/leading-zero-sign-1[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       leading-zero-sign-1 = -01

[1m     output from parser-cmd (stdout):[0m
       {
         "leading-zero-sign-1": {
           "type": "integer",
           "value": "-1"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/leading-zero-sign-2[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       leading-zero-sign-2 = +01

[1m     output from parser-cmd (stdout):[0m
       {
         "leading-zero-sign-2": {
           "type": "integer",
           "value": "1"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/leading-zero-sign-3[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       leading-zero-sign-3 = +0_1

[1m     output from parser-cmd (stdout):[0m
       {
         "leading-zero-sign-3": {
           "type": "integer",
           "value": "1"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/negative-bin[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       negative-bin = -0b11010110

[1m     output from parser-cmd (stdout):[0m
       {
         "negative-bin": {
           "type": "integer",
           "value": "-214"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/negative-hex[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       negative-hex = -0xff

[1m     output from parser-cmd (stdout):[0m
       {
         "negative-hex": {
           "type": "integer",
           "value": "-255"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/positive-bin[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       positive-bin = +0b11010110

[1m     output from parser-cmd (stdout):[0m
       {
         "positive-bin": {
           "type": "integer",
           "value": "214"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/integer/positive-hex[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       positive-hex = +0xff

[1m     output from parser-cmd (stdout):[0m
       {
         "positive-hex": {
           "type": "integer",
           "value": "255"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/key/escape[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       \u00c0 = "latin capital letter A with grave"

[1m     output from parser-cmd (stdout):[0m
       {
         "√Ä": {
           "type": "string",
           "value": "latin capital letter A with grave"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/key/single-open-bracket[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       [

[1m     output from parser-cmd (stdout):[0m
       {}

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/bad-byte-escape[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       naughty = "\xAg"

[1m     output from parser-cmd (stdout):[0m
       {
       	"naughty": {
       	"type": "string",
       	"value": "\xAg"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/bad-hex-esc-1[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       bad-hex-esc-1 = "\x0g"

[1m     output from parser-cmd (stdout):[0m
       {
       	"bad-hex-esc-1": {
       	"type": "string",
       	"value": "\x0g"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/bad-hex-esc-2[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       bad-hex-esc-2 = "\xG0"

[1m     output from parser-cmd (stdout):[0m
       {
       	"bad-hex-esc-2": {
       	"type": "string",
       	"value": "\xG0"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/bad-hex-esc-3[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       bad-hex-esc-3 = "\x"

[1m     output from parser-cmd (stdout):[0m
       {
       	"bad-hex-esc-3": {
       	"type": "string",
       	"value": "\x"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/bad-hex-esc-4[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       bad-hex-esc-4 = "\x 50"

[1m     output from parser-cmd (stdout):[0m
       {
       	"bad-hex-esc-4": {
       	"type": "string",
       	"value": "\x 50"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/bad-hex-esc-5[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       bad-hex-esc-5 = "\x 50"

[1m     output from parser-cmd (stdout):[0m
       {
       	"bad-hex-esc-5": {
       	"type": "string",
       	"value": "\x 50"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/basic-byte-escapes[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       answer = "\x33"

[1m     output from parser-cmd (stdout):[0m
       {
       	"answer": {
       	"type": "string",
       	"value": "\x33"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/basic-out-of-range-unicode-escape-1[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       a = "\UFFFFFFFF"

[1m     output from parser-cmd (stdout):[0m
       {
       	"a": {
       	"type": "string",
       	"value": "\UFFFFFFFF"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/basic-out-of-range-unicode-escape-2[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       a = "\U00D80000"

[1m     output from parser-cmd (stdout):[0m
       {
       	"a": {
       	"type": "string",
       	"value": "\U00D80000"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/basic-unknown-escape[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       a = "\@"

[1m     output from parser-cmd (stdout):[0m
       {
       	"a": {
       	"type": "string",
       	"value": "\@"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/multiline-bad-escape-2[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # \<Space> is not a valid escape.
       k = """t\ t"""

[1m     output from parser-cmd (stdout):[0m
       {
         "k": {
           "type": "string",
           "value": "tt"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/multiline-bad-escape-3[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # \<Space> is not a valid escape.
       k = """t\ """

[1m     output from parser-cmd (stdout):[0m
       {
         "k": {
           "type": "string",
           "value": "t"
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/string/multiline-escape-space[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       a = """
         foo \ \n
         bar"""

[1m     output from parser-cmd (stdout):[0m
       {
       	"a": {
       	"type": "string",
       	"value": "  foo 
       
         bar"
       }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/table/append-to-array-with-dotted-keys[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       [[a.b]]
       
       [a]
       b.y = 2

[1m     output from parser-cmd (stdout):[0m
       {
       	"a": {
       	"b": 
       }
       
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/table/append-with-dotted-keys-1[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # First a.b.c defines a table: a.b.c = {z=9}
       #
       # Then we define a.b.c.t = "str" to add a str to the above table, making it:
       #
       #   a.b.c = {z=9, t="..."}
       #
       # While this makes sense, logically, it was decided this is not valid TOML as
       # it's too confusing/convoluted.
       # 
       # See: https://github.com/toml-lang/toml/issues/846
       #      https://github.com/toml-lang/toml/pull/859
       
       [a.b.c]
         z = 9
       
       [a]
         b.c.t = "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"

[1m     output from parser-cmd (stdout):[0m
       {
         "a": {
           "b": {
             "c": {
               "t": {
                 "type": "string",
                 "value": "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"
               },
               "z": {
                 "type": "integer",
                 "value": "9"
               }
             }
           }
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/table/append-with-dotted-keys-2[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       # This is the same issue as in injection-1.toml, except that nests one level
       # deeper. See that file for a more complete description.
       
       [a.b.c.d]
         z = 9
       
       [a]
         b.c.d.k.t = "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"

[1m     output from parser-cmd (stdout):[0m
       {
         "a": {
           "b": {
             "c": {
               "d": {
                 "k": {
                   "t": {
                     "type": "string",
                     "value": "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"
                   }
                 },
                 "z": {
                   "type": "integer",
                   "value": "9"
                 }
               }
             }
           }
         }
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/table/array-empty[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       [[]]
       name = "Born to Run"

[1m     output from parser-cmd (stdout):[0m
       {
       	"": 
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/table/empty[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       []

[1m     output from parser-cmd (stdout):[0m
       {
         "": {}
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/table/llbrace[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       [ [table]]

[1m     output from parser-cmd (stdout):[0m
       {
       	"table": 
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/table/rrbrace[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       [[table] ]

[1m     output from parser-cmd (stdout):[0m
       {
       	"table": 
       }

[1m     want:[0m
       Exit code 1

[1;38;5;0;48;5;224mFAIL[0m [1minvalid/table/whitespace[0m
[1;38;5;0;48;5;224m [0m    Expected an error, but no error was reported.

[1m     input sent to parser-cmd:[0m
       [invalid key]

[1m     output from parser-cmd (stdout):[0m
       {
         "invalidkey": {}
       }

[1m     want:[0m
       Exit code 1

toml-test [.\zig-out\bin\test-parser.exe]: using embedded tests: 300 passed, 115 failed
